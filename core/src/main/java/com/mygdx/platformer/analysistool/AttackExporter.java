package com.mygdx.platformer.analysistool;

import com.mygdx.platformer.attacks.NecromancerAttackTemplate;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.List;

/**
 * Utility class for exporting procedurally or recombinantly generated attack
 * compounds
 * as Java source files for further analysis.
 * <p>
 * This class is primarily used in the data gathering pipeline for the project.
 * It takes
 * collections of {@link NecromancerAttackTemplate} objects—representing
 * different attack
 * patterns generated by PCG (Procedural Content Generation) or RCG
 * (Reuse-based Content Generation)
 * methods—and serializes them into Java classes. Each generated class
 * encapsulates the logic
 * of a single attack, including its movement and modifier code, and is placed
 * in a structured
 * output directory for later static analysis.
 * <p>
 * The generated files are used to measure code complexity
 * as part of the research and analysis process. This enables automated,
 * large-scale evaluation
 * of generated attack logic.
 * </p>
 *
 * <h2>Usage</h2>
 *
 * <pre>
 * List&lt;List&lt;NecromancerAttackTemplate&gt;&gt; compounds = ...; // generated attacks
 * int generation = 0;
 * String method = "PCG";
 * AttackExporter.exportCompounds(compounds, generation, method);
 * </pre>
 *
 * <h2>Output Structure</h2>
 * <ul>
 * <li>out/generated/{method}/gen{generation}/compound_{compoundId}/NecromancerAttack_{attackId}.java</li>
 * </ul>
 *
 * @see NecromancerAttackTemplate
 * @see com.mygdx.platformer.analysistool.AttackGenerationExporter
 * @author Daniel Jönsson
 * @author Robert Kullman
 */
public class AttackExporter {

    private static final String OUTPUT_DIR = "out/generated/";

    /**
     * Exports a list of attack compounds to Java source files for analysis.
     * <p>
     * Each compound (a list of {@link NecromancerAttackTemplate}) is written to its
     * own
     * subdirectory, and each attack within a compound is serialized as a separate
     * Java class.
     * The generated classes include executable logic for the attack, suitable for
     * static
     * analysis tools.
     * </p>
     *
     * @param compounds  The list of attack compounds to export.
     * @param generation The generation number (used for output directory
     *                   structure).
     * @param method     The generation method name (e.g., "PCG" or "RCG").
     */
    public static void exportCompounds(List<List<NecromancerAttackTemplate>> compounds, int generation, String method) {
        String baseFolderPath = OUTPUT_DIR + method.toLowerCase() + "/gen" + generation;
        new File(baseFolderPath).mkdirs();

        for (int compoundId = 0; compoundId < compounds.size(); compoundId++) {
            List<NecromancerAttackTemplate> compound = compounds.get(compoundId);
            String compoundFolder = baseFolderPath + "/compound_" + compoundId;
            new File(compoundFolder).mkdirs();

            for (int attackId = 0; attackId < compound.size(); attackId++) {
                NecromancerAttackTemplate attack = compound.get(attackId);
                String filename = compoundFolder + "/NecromancerAttack_" + attackId + ".java";

                try (FileWriter writer = new FileWriter(filename)) {
                    writer.write(convertAttackToJavaClass(attack, attackId, generation, compoundId, method));
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    /**
     * Converts a {@link NecromancerAttackTemplate} into a Java class source code
     * string.
     * <p>
     * The generated class includes all logic required to instantiate and execute
     * the attack,
     * including movement and modifier code, and is placed in a package structure
     * that reflects
     * the generation method, generation number, and compound ID. This method is
     * used internally
     * by {@link #exportCompounds(List, int, String)} to serialize each attack for
     * later static
     * analysis (e.g., code complexity, coverage).
     * </p>
     *
     * @param attack     The attack template to convert.
     * @param attackId   The index of the attack within its compound.
     * @param generation The generation number.
     * @param compoundId The compound ID.
     * @param method     The generation method (e.g., "PCG" or "RCG").
     * @return The Java source code for the generated attack class.
     */
    private static String convertAttackToJavaClass(NecromancerAttackTemplate attack, int attackId, int generation,
            int compoundId, String method) {
        String packageName = "generated." + method.toLowerCase() + ".gen" + generation + ".compound_" + compoundId
                + ";";
        System.out.println(packageName);
        return "package " + packageName + "\n\n" +
                "import com.badlogic.gdx.math.Vector2;\n" +
                "import com.badlogic.gdx.physics.box2d.World;\n" +
                "import com.mygdx.platformer.attacks.BaseAttack;\n" +
                "import com.mygdx.platformer.attacks.NecromancerAttack;\n" +
                "import com.badlogic.gdx.physics.box2d.Body;\n\n" +
                "public class NecromancerAttack_" + attackId + " {\n\n" +
                "    public BaseAttack execute(World world, Vector2 initialPos, int directionModifier, float multiplier) {\n"
                +
                "        int damage = " + attack.getDamage() + ";\n" +
                "        float speed = " + attack.getSpeed() + "f;\n" +
                "        BaseAttack attack = new NecromancerAttack(world, Math.round(damage * multiplier), speed, initialPos.x, initialPos.y, directionModifier);\n"
                +
                attack.getMovementLogicCode() + "\n" +
                attack.getModifierLogicCode() + "\n" +
                "        return attack;\n" +
                "    }\n" +
                "}\n";
    }
}
